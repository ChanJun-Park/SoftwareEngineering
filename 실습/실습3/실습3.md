# 실습3

## digraph

2개 이상의 atomic model들이 결합한 형태

## processor atomic model

다음과 같은 특징이 있다.

- 주된 상태는 passive상태.
- Inport에서 job을 받아서 processing한 다음, Outport로 내보낸다.

![1](image/1.png)

## processor atomic model 실행 흐름

- External Transition Function  
inport로 job이 들어왔을 때
  - passive 상태라면 processing_time동안 busy 상태를 유지
  - busy 상태라면 해당 job을 무시하고 continue

- Internal Transition Function  
  - 만약 busy 상태라면 passive상태로 바꾸고 무한 대기

- Output Function  
External Transition Function에서 받은 job을 outport로 보내기

## processor 주요 코드

> proc.java

```java
public void deltext(double e, message x)
{
  Continue(e); // 멈추지 않은한 아래 코드 실행
  if (phaseIs("passive"))
  {
    for (int i = 0; i < x.getLength(); i++)
    {
      if(messageOnPort(x, "in", i))
      {
        job = x.getValOnPort("in", i);
        holdIn("busy", processing_time);
      }

    }
  }
}

public void deltint()
{
  // external에서 처리가 끝나면 output으로 이동, 다시 internal로 이동
  // phaseIs를 다시 passive상태로 전환시킨다.
  if (phaseIs("busy"))
  {
    job = new entity("");
    holdIn("passive", INFINITY);
  }


}

public message out()
{
  message m = new message();
  if(phaseIs("busy"))
  {
    // job은 위쪽 (external)에서 처리한 job이다.
    m.add(makeContent("out", job));
  }
  return m;
}
```

## digraph 생성코드

> gproc.java

```java
public gproc()
{
  super("gproc");

  ViewableAtomic g = new genr("g", 10);
  ViewableAtomic p = new proc("p", 10);

  add(g); // 실제로 화면에 추가하는 부분
  add(p);

  addCoupling(g, "out", p, "in"); // g의 out에서 p의 in으로 들어간다.
  addCoupling(p, "out", g, "in");
}
```
